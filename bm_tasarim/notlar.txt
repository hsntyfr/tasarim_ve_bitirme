1. neden heap_1.c kullanÄ±ldÄ±: Ã§Ã¼nkÃ¼ diÄŸerlerinde malloc gibi metotlar var. malloc metodu Ã§alÄ±ÅŸÄ±rken dinamik olarak yer arÄ±yor ve bu yÃ¼zden zamanÄ±n deterministik olma ÅŸartÄ± ihlal edilebilir. Bu yÃ¼zden Ã¶n tanÄ±mllÄ± bÃ¼yÃ¼klÃ¼kte yer alÄ±nÄ±p bÄ±rakÄ±lmasÄ± deterministiklik ÅŸartÄ±nÄ± saÄŸlar.
2. GerÃ§ek Sistemlerde (Genel)
GerÃ§ek zamanlÄ± olmayan sistemlerde (Ã¶rneÄŸin Linux, glibc malloc):
Daha karmaÅŸÄ±k algoritmalar kullanÄ±lÄ±r:
First-fit, Best-fit, Buddy system, TLSF (Two Level Segregated Fit) vb.
Ã‡oÄŸu â€œcoalescingâ€ iÅŸlemini lazy (tembel) yapar:
Yani anÄ±nda deÄŸil, sonradan uygun olduÄŸunda birleÅŸtirir.
BazÄ±larÄ± â€œbellek sayfalarÄ±nÄ± (pages)â€ iÅŸletim sistemine iade edebilir.
GerÃ§ek zamanlÄ± (RTOS) sistemlerde ise:
Coalescing genellikle sÄ±nÄ±rlÄ± veya yasaklanmÄ±ÅŸtÄ±r
Ã§Ã¼nkÃ¼ birleÅŸtirme sÃ¼resi deÄŸiÅŸken â†’ nondeterministik olur.
Bunun yerine sabit boyutlu blok ayÄ±rma (fixed-block allocator) kullanÄ±lÄ±r
(Ã¶rnek: â€œmemory poolâ€).
3. bump yÃ¶ntemi ile ilerleniyor. stack gibi yer iÅŸgal edildikÃ§e sayaÃ§ ileri gidiyor. eÄŸer gerilerden bir gÃ¶revin iÅŸi biterse gÃ¶rev kendini reclaim list iÃ§ine ekliyor. listenin boyutu sabit olduÄŸu iÃ§in deterministlikte sorun yok. 
4. loglama sistemi kurulmasÄ± iyi olur.
5. 64kb ram var
6. partitionlar arasÄ± eriÅŸimin denetimi iÃ§in MPU kullanÄ±lacak.
7. sunumda heap 1 2 3 4 5 arasÄ±ndaki farklar bir tabloda toplanabilir
8. ğŸ¯ Ã–nerilen BÃ¶lÃ¼m YapÄ±sÄ± (FreeRTOS & ARINC 653 Projesi iÃ§in)
BÃ–LÃœM 1. GÄ°RÄ°Å
GerÃ§ek zamanlÄ± sistemlerin Ã¶nemi
HavacÄ±lÄ±k sistemlerinde gÃ¼venlik ve deterministik davranÄ±ÅŸ ihtiyacÄ±
ARINC 653 standardÄ±nÄ±n amacÄ±
Ã‡alÄ±ÅŸmanÄ±n hedefi (FreeRTOS Ã¼zerinde ARINC 653 servislerinin gerÃ§ekleÅŸtirilmesi)
Raporun genel yapÄ±sÄ±
BÃ–LÃœM 2. MEVCUT YAKLAÅIMLAR VE LÄ°TERATÃœR Ä°NCELEMESÄ°
ARINC 653 standardÄ±nÄ±n genel yapÄ±sÄ±
Benzer Ã§alÄ±ÅŸmalarda kullanÄ±lan RTOSâ€™lar (Deos, VxWorks 653, PikeOS vb.)
FreeRTOSâ€™un yapÄ±sÄ± ve kÄ±sÄ±tlarÄ±
Mevcut Ã§Ã¶zÃ¼mler ile bu projenin farklÄ± yÃ¶nleri
BÃ–LÃœM 3. KULLANILAN TEKNOLOJÄ°LER VE ARAÃ‡LAR
DonanÄ±m platformu (STM32 serisi, bellek yapÄ±sÄ±, MPU kullanÄ±mÄ±)
YazÄ±lÄ±m araÃ§larÄ± (FreeRTOS, CubeIDE veya VS Code + CMake, ARM Toolchain)
Standart ve dokÃ¼manlar (DO-178C, ARINC 653 Part 1/2)
Destekleyici araÃ§lar (Git, SimÃ¼lasyon, Debugging, SWO vb.)
BÃ–LÃœM 4. SÄ°STEM TASARIMI
Genel sistem mimarisi (Partition yapÄ±sÄ±, APEX katmanÄ±, gÃ¶revler)
Bellek ve zaman izolasyonu (MPU yapÄ±landÄ±rmasÄ±)
FreeRTOS tasklerinin ARINC 653 Partitionâ€™larÄ±na haritalanmasÄ±
APEX servislerinin implementasyonu
Process Management
Inter-Partition Communication
Time Management
Health Monitoring
ZamanlayÄ±cÄ± yapÄ±sÄ± (partition scheduler + task scheduler iliÅŸkisi)
BÃ–LÃœM 5. UYGULAMA VE TESTLER
Deney ortamÄ± (STM32 kartÄ±, simÃ¼lasyon veya emÃ¼lasyon ortamÄ±)
Test senaryolarÄ±
Task izolasyonu testi
Partition switching testi
SaÄŸlÄ±k izleme (Health Monitor) testi
SonuÃ§larÄ±n deÄŸerlendirilmesi
BÃ–LÃœM 6. SONUÃ‡LAR VE Ã–NERÄ°LER
FreeRTOS Ã¼zerinde ARINC 653 servislerinin uygulanabilirliÄŸi
KarÅŸÄ±laÅŸÄ±lan kÄ±sÄ±tlar (Ã¶rneÄŸin deterministiklik, hafÄ±za sÄ±nÄ±rlamalarÄ±)
Gelecek Ã§alÄ±ÅŸmalar (Ã¶rneÄŸin Ã§ok Ã§ekirdek desteÄŸi, DO-178C uyumlaÅŸtÄ±rmasÄ±)
KAYNAKLAR
EKLER
APEX API tablosu
MPU konfigÃ¼rasyon Ã¶rnekleri
GÃ¶rev planlama diyagramÄ±
9.ğŸ§© 1ï¸âƒ£ PARTITION MANAGEMENT SERVICES
AmaÃ§: Sistemdeki partitionâ€™larÄ±n yÃ¶netimi.
Partition = izole edilmiÅŸ bir uygulama alanÄ±.
Fonksiyon	AÃ§Ä±klama
SET_PARTITION_MODE()	Partitionâ€™Ä± COLD_START, WARM_START, NORMAL veya IDLE moda geÃ§irir.
GET_PARTITION_STATUS()	Partitionâ€™Ä±n kimliÄŸi, modu, zamanÄ± gibi bilgileri dÃ¶ner.
ğŸŸ© Not: Genelde bu Ã§aÄŸrÄ±lar sadece sistem baÅŸlangÄ±cÄ±nda (partition initialization aÅŸamasÄ±nda) yapÄ±labilir.
âš™ï¸ 2ï¸âƒ£ PROCESS MANAGEMENT SERVICES
AmaÃ§: FreeRTOSâ€™taki taskâ€™lerin APEX karÅŸÄ±lÄ±ÄŸÄ±.
Her process bir partition iÃ§inde Ã§alÄ±ÅŸÄ±r.
Fonksiyon	AÃ§Ä±klama
CREATE_PROCESS()	Yeni bir process (task) oluÅŸturur.
START()	Processâ€™i Ã§alÄ±ÅŸtÄ±rÄ±labilir (ready) hÃ¢line getirir.
STOP_SELF()	Process kendi kendini durdurur.
STOP()	BaÅŸka bir processâ€™i durdurur.
DELAYED_START()	Belirli bir zaman sonra process baÅŸlatÄ±r.
SUSPEND_SELF()	Process kendi kendini askÄ±ya alÄ±r.
SUSPEND()	BaÅŸka bir processâ€™i askÄ±ya alÄ±r.
RESUME()	AskÄ±ya alÄ±nmÄ±ÅŸ bir processâ€™i yeniden baÅŸlatÄ±r.
SET_PRIORITY()	Processâ€™in Ã¶nceliÄŸini deÄŸiÅŸtirir.
GET_PROCESS_ID()	Mevcut processâ€™in kimliÄŸini dÃ¶ner.
GET_PROCESS_STATUS()	Processâ€™in durumu, Ã¶nceliÄŸi, zamanÄ± vb. bilgilerini verir.
ğŸŸ¦ FreeRTOS karÅŸÄ±lÄ±ÄŸÄ±:
xTaskCreate(), vTaskDelete(), vTaskSuspend(), vTaskResume(), vTaskPrioritySet(), vb.
â±ï¸ 3ï¸âƒ£ TIME MANAGEMENT SERVICES
AmaÃ§: Zamanla ilgili iÅŸlemler (sistem saati, gecikmeler, timerâ€™lar).
Fonksiyon	AÃ§Ä±klama
GET_TIME()	Åu anki sistem zamanÄ±nÄ± dÃ¶ner.
REPLENISH()	(BazÄ± sistemlerde) zaman bÃ¶lÃ¼ÅŸÃ¼mÃ¼nÃ¼ gÃ¼nceller.
TIMED_WAIT()	Belirtilen sÃ¼re kadar bekler (FreeRTOSâ€™taki vTaskDelay() benzeri).
PERIODIC_WAIT()	Periodik gÃ¶revler iÃ§in zamanlamayÄ± ayarlar (Ã¶rneÄŸin her 20 ms Ã§alÄ±ÅŸ).
GET_PARTITION_TIME()	Partitionâ€™Ä±n iÃ§ saatini verir.
SET_PARTITION_TIME()	(Opsiyonel) Partitionâ€™Ä±n iÃ§ saatini ayarlamak iÃ§in.
ğŸŸ¨ FreeRTOS karÅŸÄ±lÄ±ÄŸÄ±:
vTaskDelay(), xTaskGetTickCount(), xTimer... fonksiyonlarÄ±.
ğŸ”„ 4ï¸âƒ£ INTER-PARTITION COMMUNICATION SERVICES
AmaÃ§: FarklÄ± partitionâ€™lar arasÄ±nda mesajlaÅŸma (IPC).
Ä°ki tÃ¼r var: Sampling Port ve Queuing Port.
ğŸ§­ a) Sampling Port Services
Fonksiyon	AÃ§Ä±klama
CREATE_SAMPLING_PORT()	Bir â€œtek mesajlÄ±kâ€ haberleÅŸme portu oluÅŸturur.
WRITE_SAMPLING_MESSAGE()	Yeni bir mesajÄ± porta yazar (Ã¶nceki mesajÄ± ezer).
READ_SAMPLING_MESSAGE()	Porttaki en son mesajÄ± okur.
GET_SAMPLING_PORT_ID()	Sampling port kimliÄŸini dÃ¶ner.
GET_SAMPLING_PORT_STATUS()	Portun durumu, refresh zamanÄ± vb. verir.
ğŸŸ¢ Ã–zellik: Sadece en son mesaj saklanÄ±r.
ğŸ§³ b) Queuing Port Services
Fonksiyon	AÃ§Ä±klama
CREATE_QUEUING_PORT()	FIFO tarzÄ± bir mesaj kuyruÄŸu oluÅŸturur.
SEND_QUEUING_MESSAGE()	KuyruÄŸa yeni mesaj ekler.
RECEIVE_QUEUING_MESSAGE()	Kuyruktan mesaj alÄ±r.
GET_QUEUING_PORT_ID()	Kuyruk kimliÄŸini dÃ¶ner.
GET_QUEUING_PORT_STATUS()	Kuyruk doluluk, yÃ¶n vb. bilgileri verir.
ğŸŸ£ Ã–zellik: Mesajlar bir sÄ±ra (queue) hÃ¢linde saklanÄ±r.
ğŸŸ¨ FreeRTOS karÅŸÄ±lÄ±ÄŸÄ±: xQueueCreate(), xQueueSend(), xQueueReceive().
ğŸ’¬ 5ï¸âƒ£ INTRA-PARTITION COMMUNICATION SERVICES
AmaÃ§: AynÄ± partition iÃ§indeki processâ€™ler arasÄ±nda veri paylaÅŸÄ±mÄ±.
a) Buffer
Fonksiyon	AÃ§Ä±klama
CREATE_BUFFER()	FIFO buffer oluÅŸturur.
SEND_BUFFER()	MesajÄ± bufferâ€™a gÃ¶nderir.
RECEIVE_BUFFER()	Bufferâ€™dan mesaj alÄ±r.
GET_BUFFER_ID()	Buffer kimliÄŸini dÃ¶ner.
GET_BUFFER_STATUS()	Bufferâ€™daki mesaj sayÄ±sÄ±nÄ± verir.
b) Blackboard
Fonksiyon	AÃ§Ä±klama
CREATE_BLACKBOARD()	Ortak hafÄ±za alanÄ± oluÅŸturur.
DISPLAY_BLACKBOARD()	MesajÄ± yaz (Ã¶nceki mesajÄ± ezer).
READ_BLACKBOARD()	Son yazÄ±lan mesajÄ± okur.
CLEAR_BLACKBOARD()	Blackboardâ€™u temizler.
GET_BLACKBOARD_ID()	Blackboard kimliÄŸini dÃ¶ner.
GET_BLACKBOARD_STATUS()	Durum bilgisi verir.
c) Semaphore
Fonksiyon	AÃ§Ä±klama
CREATE_SEMAPHORE()	SayÄ±cÄ± semafor oluÅŸturur.
WAIT_SEMAPHORE()	Semaforu alÄ±r (0 ise bekler).
SIGNAL_SEMAPHORE()	Semaforu bÄ±rakÄ±r.
GET_SEMAPHORE_ID()	Semafor kimliÄŸini dÃ¶ner.
GET_SEMAPHORE_STATUS()	Semaforun deÄŸerini dÃ¶ner.
d) Event
Fonksiyon	AÃ§Ä±klama
SET_EVENT()	Bir processâ€™e olay sinyali gÃ¶nderir.
RESET_EVENT()	OlayÄ± sÄ±fÄ±rlar.
WAIT_EVENT()	OlayÄ±n gerÃ§ekleÅŸmesini bekler.
GET_EVENT_ID()	Event kimliÄŸini dÃ¶ner.
GET_EVENT_STATUS()	OlayÄ±n mevcut durumunu dÃ¶ner.
ğŸŸ¦ FreeRTOS karÅŸÄ±lÄ±ÄŸÄ±: queue, semaphore, event group, shared memory, vb.
ğŸ›¡ï¸ 6ï¸âƒ£ HEALTH MONITORING SERVICES
AmaÃ§: HatalarÄ±n izlenmesi ve yÃ¶netimi.
Her partitionâ€™Ä±n kendi health monitorâ€™Ã¼ vardÄ±r.
Fonksiyon	AÃ§Ä±klama
REPORT_APPLICATION_ERROR()	Bir hata raporu oluÅŸturur.
CREATE_ERROR_HANDLER()	Partition seviyesinde Ã¶zel hata yÃ¶neticisi oluÅŸturur.
ğŸŸ¥ Not: Sistem hatalarÄ± (Ã¶rneÄŸin illegal memory access) iÃ§in merkezi bir System Health Monitor de bulunur.
âš ï¸ 7ï¸âƒ£ ERROR HANDLING SERVICES
AmaÃ§: APEX Ã§aÄŸrÄ±larÄ±ndan dÃ¶nen hata kodlarÄ±.
Her APEX fonksiyonu genelde RETURN_CODE_TYPE isimli bir parametre dÃ¶ner:
NO_ERROR
INVALID_PARAM
INVALID_MODE
NOT_AVAILABLE
TIMED_OUT
...
Yani hata durumlarÄ± standartlaÅŸtÄ±rÄ±lmÄ±ÅŸtÄ±r.
ğŸ§® 8ï¸âƒ£ PROCESS SCHEDULING PARAMETERS
AmaÃ§: Process zamanlamasÄ± ile ilgili sabitler ve tipler.
TanÄ±m	AÃ§Ä±klama
APERIODIC / PERIODIC	GÃ¶rev tipi.
DEADLINE_TYPE	Zaman aÅŸÄ±mÄ± tÃ¼rÃ¼.
PROCESS_ATTRIBUTE_TYPE	Process oluÅŸturulurken kullanÄ±lan yapÄ± (isim, yÄ±ÄŸÄ±n, Ã¶ncelik, periyot vb.).
ğŸ”š Ã–zet Tablo
Grup	Ä°ÅŸlev	FreeRTOS KarÅŸÄ±lÄ±ÄŸÄ±
Partition Management	Partition modlarÄ±	Yok (statik yapÄ±)
Process Management	Task yÃ¶netimi	Task API
Time Management	Zaman iÅŸlemleri	Delay / Tick API
Inter-Partition Comm	Portlar (IPC)	Yok (kendi protokolÃ¼)
Intra-Partition Comm	Queue / Semaphore / Event	Queue / Semaphores / EventGroups
Health Monitoring	Hata izleme	Yok (kendin eklersin)
Error Handling	Hata kodlarÄ±	Return deÄŸerleri
Scheduling Params	Priority / Deadline	Task priority, tick rate
10.